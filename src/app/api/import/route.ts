import { NextResponse } from "next/server";
import { createClient } from "@supabase/supabase-js";
import { cookies } from "next/headers";

export async function POST(req: Request) {
  try {
    const { shareId, hex } = await req.json();
    const cookieStore = await cookies();
    const anonymousId = cookieStore.get("anonymous_id")?.value;

    if (!anonymousId) {
      return NextResponse.json(
        { error: "No anonymous ID found" },
        { status: 401 }
      );
    }

    if (!shareId) {
      return NextResponse.json(
        { error: "Share ID is required" },
        { status: 400 }
      );
    }

    const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL || "";
    const supabaseServiceKey = process.env.SUPABASE_SERVICE_ROLE_KEY || "";

    if (!supabaseUrl || !supabaseServiceKey) {
      return NextResponse.json(
        { error: "Server config error" },
        { status: 500 }
      );
    }

    const supabase = createClient(supabaseUrl, supabaseServiceKey);

    // 1. Fetch the shared collection snapshot
    const { data: shareData, error: fetchError } = await supabase
      .from("shared_collections")
      .select("snapshot_data")
      .eq("id", shareId)
      .single();

    if (fetchError || !shareData) {
      return NextResponse.json(
        { error: "Shared collection not found" },
        { status: 404 }
      );
    }

    // 2. Prepare data for insertion
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    let snapshotItems = shareData.snapshot_data as any[];

    // If hex is provided, filter for that specific color
    if (hex) {
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      snapshotItems = snapshotItems.filter((item: any) => item.hex === hex);
      if (snapshotItems.length === 0) {
        return NextResponse.json(
          { error: "Color not found in collection" },
          { status: 404 }
        );
      }
    }

    // Map snapshot items to diagnoses table structure
    // We treat these as new "diagnoses" but with source metadata
    const newDiagnoses = snapshotItems.map((item) => ({
      // Generate new UUID for the import
      // Note: id is usually generated by client in original flow, but here we can let DB generate or generate here.
      // schema.sql logic says "client generated UUID", so we might need to generate it if table doesn't have default.
      // Checking table schema... "id uuid not null primary key". It doesn't say "default gen_random_uuid()".
      // We must generate UUIDs. Pgcrypto is enabled.
      // Let's rely on DB default if it exists, otherwise generate.
      // Actually schema says: "id uuid not null primary key", NO DEFAULT.
      // So we MUST generate UUIDs.
      // We can use crypto.randomUUID() in Node/Edge.

      id: crypto.randomUUID(),
      anonymous_id: anonymousId,
      created_at: new Date().toISOString(), // Import time is "now"

      // Color data
      selected_color_hex: item.hex, // Original schema used 'selected_color_hex', but verify if 'hex' is used in app.
      // Looking at previous code, user code reads 'hex' from 'diagnoses'.
      // Wait, schema.sql says 'selected_color_hex', but app uses 'hex'?
      // Let's check 'diagnoses' table definition from previous artifacts or context.
      // The user schema image shows 'hex' column in diagnoses table!
      // Image: diagnoses -> hex, hue, lightness, chroma...
      // My schema.sql artifact might be outdated or user changed it.
      // I should follow the IMAGE schema. Column is 'hex'.
      hex: item.hex,

      // Restore other color props if available in snapshot, or re-calculate?
      // Snapshot likely has them if it was a select * from diagnoses.
      // If not, we might need to re-calc. But let's assume snapshot has basic data.
      // If snapshot is just hex, ID, createdAt... we might be missing L/C/H columns which are NOT NULL in schema.sql?
      // Schema image shows oklch_l, oklch_c etc?
      // Image shows: hue, lightness, chroma (numeric).
      // Let's try to copy if present, or provide defaults/recalc.
      // Ideally we should recalculate to be safe.

      // Metadata
      source_type: "share_import",
      source_id: shareId,

      // Fill required columns that might be missing in simplified snapshot
      // Image shows: theme, algorithm_version, duration_seconds(int4), locale, user_agent, country, region
      // We can set some defaults for imports.
      algorithm_version: "import_v1",
      locale: "ja", // or get from request headers?
      // Assuming non-strict columns or allow nulls?
      // Image doesn't show Not Null constraints visually except maybe diamonds?
      // Solid diamond = Not Null?
      // hex, hue, lightness, chroma have Solid diamonds.
      // created_at, id have keys/diamonds.
      // We need to be careful about L/C/H.
    }));

    // Recalculate LCH if needed (using culori logic would be best, but this is server side edge/node)
    // For now, let's assume we can insert 'hex' and maybe LCH are computed or we copy from snapshot if it had them.
    // The previous /api/share code selected "id, hex, created_at". It did NOT select L/C/H!
    // This is a problem. The snapshot only has hex.
    // We MUST recalculate L/C/H to insert valid rows into diagnoses.
    // I need to import culori or color library to calculate.

    // HOWEVER, I don't want to break if libraries are missing.
    // Let's try to import culori as it is in package.json.

    const { converter } = await import("culori");
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const toOklch = converter("oklch") as (color: string) => any;

    const validatedDiagnoses = newDiagnoses.map((d) => {
      const color = toOklch(d.hex);
      return {
        ...d,
        // Map to schema columns from Image
        // Image: lightness, chroma, hue (numeric)
        lightness: color?.l ?? 0,
        chroma: color?.c ?? 0,
        hue: color?.h ?? 0,

        // Dummy values for required fields
        theme: "import",
        duration_seconds: 0,
        user_agent: "import_api",
        country: "unknown",
        region: "unknown",
      };
    });

    const { error: insertError } = await supabase
      .from("diagnoses")
      .insert(validatedDiagnoses);

    if (insertError) {
      console.error("Import error:", insertError);
      return NextResponse.json({ error: "Failed to import" }, { status: 500 });
    }

    return NextResponse.json({ success: true, count: newDiagnoses.length });
  } catch (err) {
    console.error("Import API error:", err);
    return NextResponse.json(
      { error: "Internal Server Error" },
      { status: 500 }
    );
  }
}
